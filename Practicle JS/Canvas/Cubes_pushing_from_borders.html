<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>Cubes_pushing_from_borders</title>
    <style>
    canvas {
      margin: 0px auto; /*задаем канвасу границы, стили*/
      border: none;
      display:block;
      background: grey;
      border-radius: 5px;
    }
    </style>
  </head>
  <body>
    <canvas width = "800" height = "400"></canvas>
    <script>
      const canvas = document.querySelector('canvas');
      const ctx = canvas.getContext('2d');
      const [width, height] = [canvas.width, canvas.height];

      const cubes = [];                                     /*Понимая, что нам нужно 5 квадратов(можно меньше или больше)
                                                              создадим массив квадратов                                 */
      for (let i = 0; i < 5; i++) {                         /* Что бы задавать им свойства и вызывать из массива нам нужен индекс
                                                              делаем это при помощи условия for и счетчика, командой i < 5 задается кол-во квадратов */
        cubes [i] = {                                       /*Теперь для каждого i-того куба (опишем объект) */
          x: Math.floor(Math.random() * (width - 50)),      /* задаем рандомные координаты появления кубов, что бы не пояились за макс. размер
                                                            канваса с права, вычитаем из ширины канваса ширину куба ( 50 px) */
          y: Math.floor(Math.random() * (height - 50)),     /* задаем рандомные координаты появления кубов по оси Y, что бы не пояились за макс. размер
                                                            канваса с низу, вычитаем из высоты канваса высоту куба ( 50 px) */
          speedX: Math.random() - 0.5 < 0 ? -1 : 1,         /* задаем координаты движения кубов, если команда (mathRandom - 0.5) получится отрицательным числом
                                                              по куб сместится на 1 px влево ( в сторону уменьшения оси X), если положительным числом то вправо */
          speedY: Math.random() - 0.5 < 0 ? -1 : 1          /* продолжаем задавать координаты движения кубов по оси Y, если команда (mathRandom - 0.5) получится отрицательным числом
                                                              по куб сместится на 1 px вверх ( в сторону уменьшения Y), если положительным числом то вниз */
        };
      }

      setInterval (() => {                                    /*Открываем функцию с утановкой интервала каждые 25 мл сек*/
        ctx.clearRect (0, 0, width, height);                 /*очищаем весь периметр канваса  */
        for (let i = 0; i < 5; i ++) {                       /*Что бы функция работала на все кубы делаем это при помощи условия for и счетчика индексов кубов в массиве*/
          ctx.fillRect ( cubes[i].x, cubes[i].y, 50, 50);    /* Отрисовываем кубы, размер 50 px на 50 px, координаты отрисовки получаем для каждого i-того куба из
                                                              рандомных чисел для объекта cubes [i], свойство x,y */
          cubes[i].x += cubes[i].speedX;                     /* К выданной рандомно координате по оси Х прбавляем рандомное значение направления движения (скорости speedX),
                                                              направление может быть + 1 px вправо или - 1 px влево  */
          if (cubes[i].x < 0 || cubes[i].x > width - 50){    /* Задаем условие, что бы при касании граней канваса по оси Х кубы меняли свое движение на противоположное :
                                                              если координата куба по оси Х меньше нуля или больше ширины (канваса - 50), то направление движения по оси Х
                                                              меняется в противоположную сторону. */
            cubes[i].speedX = -cubes[i].speedX;              /*Если была -1px и двигался куб влево, то минус на минус дает плюс и по оси Х
                                                              куб будет двигаться теперь вправо */
          }
          cubes[i].y += cubes[i].speedY;                     /*К выданной рандомно координате по оси Y прбавляем рандомное значение направления движения (скорости speedY),
                                                              направление может быть + 1 px вниз или - 1 px вверх*/
          if (cubes[i].y < 0 || cubes[i].y > height - 50){   /* Задаем условие, что бы при касании граней канваса по оси Y кубы меняли свое движение на противоположное :
                                                              если координата куба по оси Y меньше нуля или больше высоты (канваса - 50), то направление движения по оси Y
                                                              меняется в противоположную сторону.  */
            cubes[i].speedY = -cubes[i].speedY;              /*Если была -1px и двигался куб вверх, то минус на минус дает плюс и по оси Y
                                                              куб будет двигаться теперь вниз */
        }
      }
    }, 25);                                                   /*ВАЖНАЯ ПОМЕТКА! Как работает функция
                                                                в момент касания кубом граней канваса по оси Х он начинает двигаться в противоположную сторону , но при этом значение
                                                                ( пол. или отриц) по оси Y остается прежним
                                                                Так же и для касания по оси Y, куб изменит на противоположное,  но направление по оси Х останется прежним*/
    </script>
  </body>
</html>
